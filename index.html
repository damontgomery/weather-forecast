<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Weather Forecast</title>
  <style>
    body {
      font-family: sans-serif;
    }

    line {
      stroke: 2;
      stroke: black;
      stroke-linecap: round;
    }
    
    polyline {
      stroke-width: 5;
      stroke-linecap: round;
      opacity: 0.7;
    }

    polyline.temperature {
      stroke: red;
    }
    
    polyline.dew-point {
      stroke: green;
    }

    polyline.wind-chill {
      stroke: blue;
    }

    polyline.snow {
      stroke: gray;
    }

    polyline.rain {
      stroke: blue;
    }

    line.horizontal-gridline {
      stroke: black;
      opacity: 0.5;
      stroke-width: 1;
      stroke-dasharray: 3;
    }

    text.horizontal-gridline {
      font: normal 1rem sans-serif;
      fill: black;
    }

    line.vertical-gridline {
      stroke: black;
      opacity: 0.5;
      stroke-width: 1;
    }

    text.vertical-gridline {
      font: normal 1rem sans-serif;
      fill: black;
      text-transform: lowercase;
    }

  </style>
  <script>
    const queryParameters = new URLSearchParams(window.location.search)

    let latitude = 41.9536
    let longitude = -87.7117

    if (queryParameters.has('lat')) {
      latitude = parseFloat(queryParameters.get('lat'))
    }
    if (queryParameters.has('lon')) {
      longitude = parseFloat(queryParameters.get('lon'))
    }

    const xhr = new XMLHttpRequest()
    
    const getForecastPointsFromXML = () => {
      const xmlToArray = q => Array.from(xhr.responseXML.documentElement.querySelectorAll(q))

      const temperatures = xmlToArray('temperature[type="hourly"] > value')
        .map(n => parseInt(n.innerHTML))

      const dewPoints = xmlToArray('temperature[type="dew point"] > value')
        .map(n => parseInt(n.innerHTML))
      
      const windChills = xmlToArray('temperature[type="wind chill"] > value')
        .map(n => parseInt(n.innerHTML))
      
      const probabilityOfPercipitations = xmlToArray('probability-of-precipitation > value')
        .map(n => parseInt(n.innerHTML))

      const weatherConditions = xmlToArray('weather-conditions')
        .map(n => {
          const value = n.querySelector('value')
          if (!value) {
            return {
              type: 'none',
              coverage: 'none',
            }
          }

          return {
            type: value.getAttribute('weather-type'),
            coverage: value.getAttribute('coverage'),
          }
        })

      const startTimes = xmlToArray('start-valid-time')
        .map(n => n.innerHTML)

      const endTimes = xmlToArray('end-valid-time')
        .map(n => n.innerHTML)

      return startTimes.map((startTime, i) => ({
        startTime,
        endTime: endTimes[i],
        temperature: temperatures[i],
        dewPoint: dewPoints[i],
        windChill: windChills[i],
        probabilityOfPercipitation: probabilityOfPercipitations[i],
        weatherCondition: weatherConditions[i],
      }))
    }

    // forecastPoints: {startTime: string, endTime: string, temperature: number, dewPoint: number, windChill: number, probabilityOfPercipitation: number, weatherCondition: {type: string, coverage: string}}[]
    const drawSVG = (forecastPoints) => {
      // clear existing svg.
      document.querySelector('weather-forecast').innerHTML = ''

      const weatherForecastContainer = document.querySelector('weather-forecast')

      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg')

      const maxWidth = window.innerWidth
      const maxHeight = window.innerHeight

      svg.setAttribute('width', '100%')
      svg.setAttribute('height', '100%')
      svg.setAttribute('viewBox', `0 0 ${maxWidth} ${maxHeight}`)


      const canvasPadding = 50

      // Temperature canvas takes up top 2/3 of screen.
      const temperatureCanvasHeightPercent = 2 / 3
      const temperatureCanvasBounds = {
        x: {
          min: canvasPadding,
          max: maxWidth - canvasPadding,
          length: maxWidth - (canvasPadding * 2),
        },
        y: {
          min: canvasPadding,
          max: (maxHeight * temperatureCanvasHeightPercent) - canvasPadding,
          length: (maxHeight * temperatureCanvasHeightPercent) - (canvasPadding * 2),
        },
      }

      const precipitationCanvasBounds = {
        x: {
          min: canvasPadding,
          max: maxWidth - canvasPadding,
          length: maxWidth - (canvasPadding * 2),
        },
        y: {
          min: (maxHeight * temperatureCanvasHeightPercent) + canvasPadding,
          max: maxHeight - canvasPadding,
          length: (maxHeight * (1 - temperatureCanvasHeightPercent)) - (canvasPadding * 2),
        },
      }

      // Draw gridlines.

      // Draw time gridlines.
      forecastPoints.forEach((forecastPoint, i) => {
        const startTime = new Date(forecastPoint.startTime)

        const shouldDrawLabel = (
          i == 0 ||
          i == forecastPoints.length - 1 ||
          startTime.getHours() % 3 == 0
        )

        if (!shouldDrawLabel) {
          return
        }

        const x = temperatureCanvasBounds.x.min + temperatureCanvasBounds.x.length * (i / (forecastPoints.length - 1))

        const temperatureGridline = document.createElementNS('http://www.w3.org/2000/svg', 'line')
        temperatureGridline.setAttribute('x1', x)
        temperatureGridline.setAttribute('y1', temperatureCanvasBounds.y.min)
        temperatureGridline.setAttribute('x2', x)
        temperatureGridline.setAttribute('y2', temperatureCanvasBounds.y.max)
        temperatureGridline.classList.add('vertical-gridline')
        temperatureGridline.classList.add('temperature')
        svg.appendChild(temperatureGridline)

        const precipitationGridline = document.createElementNS('http://www.w3.org/2000/svg', 'line')
        precipitationGridline.setAttribute('x1', x)
        precipitationGridline.setAttribute('y1', precipitationCanvasBounds.y.min)
        precipitationGridline.setAttribute('x2', x)
        precipitationGridline.setAttribute('y2', precipitationCanvasBounds.y.max)
        precipitationGridline.classList.add('vertical-gridline')
        precipitationGridline.classList.add('precipitation')
        svg.appendChild(precipitationGridline)

        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text')
        text.setAttribute('x', x)
        text.setAttribute('y', maxHeight * (2/3))
        text.setAttribute('text-anchor', 'end')
        text.setAttribute('transform', `rotate(-90 ${x} ${maxHeight * (2/3)}) translate(18, 4)`)
        text.innerHTML = startTime.toLocaleString('en-US', {hour: 'numeric', hour12: true})
        text.classList.add('vertical-gridline')
        svg.appendChild(text)
      })

      // Draw Temperature gridlines.
      const temperatures = [
        ...forecastPoints.map(forecastPoint => forecastPoint.temperature),
        ...forecastPoints.map(forecastPoint => forecastPoint.dewPoint),
        ...forecastPoints.map(forecastPoint => forecastPoint.windChill),
      ].filter(n => !isNaN(n))

      const maxTemperature = Math.max(...temperatures)

      const minTemperature = Math.min(...temperatures)

      const chartGridlineSpacing = 5
      const chartMaxTemperature = Math.round(maxTemperature / chartGridlineSpacing) * chartGridlineSpacing + chartGridlineSpacing
      const chartMinTemperature = Math.round(minTemperature / chartGridlineSpacing) * chartGridlineSpacing - chartGridlineSpacing
      const chartTemperatureBounds = {
        max: chartMaxTemperature,
        min: chartMinTemperature,
        length: chartMaxTemperature - chartMinTemperature,
      }

      for (let i = chartTemperatureBounds.min; i <= chartTemperatureBounds.max; i += 5) {
        const y = temperatureCanvasBounds.y.max - temperatureCanvasBounds.y.length * ((i - chartTemperatureBounds.min) / (chartTemperatureBounds.max - chartTemperatureBounds.min))

        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line')
        line.setAttribute('x1', temperatureCanvasBounds.x.min)
        line.setAttribute('y1', y)
        line.setAttribute('x2', temperatureCanvasBounds.x.max)
        line.setAttribute('y2', y)
        line.classList.add('horizontal-gridline')
        line.classList.add('temperature')
        svg.appendChild(line)

        const axisLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text')
        axisLabel.setAttribute('x', temperatureCanvasBounds.x.min)
        axisLabel.setAttribute('y', y)
        axisLabel.setAttribute('text-anchor', 'end')
        axisLabel.setAttribute('transform', 'translate(-10, 4)')
        axisLabel.innerHTML = `${i}Â°`
        axisLabel.classList.add('horizontal-gridline')
        axisLabel.classList.add('temperature')
        svg.appendChild(axisLabel)

        // Add another in the middle.
        const middleLabel = axisLabel.cloneNode(true)
        middleLabel.setAttribute('x', temperatureCanvasBounds.x.min + 0.5 * temperatureCanvasBounds.x.length)
        middleLabel.setAttribute('transform', 'translate(0, 4)')
        svg.appendChild(middleLabel)
      }

      // points: {x: number, y: number}[]
      const drawPolyline = ({points, color= 'black', className}) => {
        const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline')
        polyline.setAttribute('points', points.filter(p => !isNaN(p.y)).map(p => `${p.x},${p.y}`).join(' '))
        polyline.setAttribute('stroke', color)
        polyline.setAttribute('fill', 'none')
        polyline.classList.add(className)
        svg.appendChild(polyline)
      }

      // Draw temperature line.
      const drawTemperatureLine = ({propertyName, className}) => {
        drawPolyline({
          points: forecastPoints.map((forecastPoint, i) => ({
            x: temperatureCanvasBounds.x.min + temperatureCanvasBounds.x.length * (i / (forecastPoints.length - 1)),
            y: temperatureCanvasBounds.y.max - temperatureCanvasBounds.y.length * ((forecastPoint[propertyName] - chartTemperatureBounds.min) / chartTemperatureBounds.length)
          })),
          className
        })
      }

      drawTemperatureLine({propertyName: 'temperature', className: 'temperature'})
      drawTemperatureLine({propertyName: 'dewPoint', className: 'dew-point'})
      drawTemperatureLine({propertyName: 'windChill', className: 'wind-chill'})

      // Precipitation
      const precipitationCoverageLabelToValueMap = new Map([
        [
          'none', {
            value: 0,
            shortLabel: '',
          }
        ],
        [
          'slight chance', {
            value: 1,
            shortLabel: 'sch',
          }
        ],
        [
          'chance', {
            value: 2,
            shortLabel: 'cha',
          }
        ],
        [
          'likely', {
            value: 3,
            shortLabel: 'like',
          }
        ],
        [
          'occasional', {
            value: 4,
            shortLabel: 'occ',
          }
        ],
      ])

      Array.from(precipitationCoverageLabelToValueMap.entries()).forEach(([_, coverageValue]) => {
        const y = precipitationCanvasBounds.y.max - precipitationCanvasBounds.y.length * (coverageValue.value / (precipitationCoverageLabelToValueMap.size - 1))

        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line')
        line.setAttribute('x1', precipitationCanvasBounds.x.min)
        line.setAttribute('y1', y)
        line.setAttribute('x2', precipitationCanvasBounds.x.max)
        line.setAttribute('y2', y)
        line.classList.add('horizontal-gridline')
        line.classList.add('precipitation')
        svg.appendChild(line)

        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text')
        text.setAttribute('x', precipitationCanvasBounds.x.min)
        text.setAttribute('y', y)
        text.setAttribute('text-anchor', 'end')
        text.setAttribute('transform', 'translate(-10, 4)')
        text.innerHTML = coverageValue.shortLabel
        text.classList.add('horizontal-gridline')
        text.classList.add('precipitation')
        svg.appendChild(text)
      })

      const drawPrecipitationLine = ({propertyName, className}) => {
        drawPolyline({
          points: forecastPoints.map((forecastPoint, i) => {
            // weatherCondition: {type: string, coverage: string}
            const weatherCondition = forecastPoint.weatherCondition

            let value = 0;

            if (weatherCondition.type === propertyName) {
              value = precipitationCoverageLabelToValueMap.get(weatherCondition.coverage).value
            }
            
            return {
              x: precipitationCanvasBounds.x.min + precipitationCanvasBounds.x.length * (i / (forecastPoints.length - 1)),
              y: precipitationCanvasBounds.y.max - precipitationCanvasBounds.y.length * (value / (precipitationCoverageLabelToValueMap.size - 1))
            }
          }),
          className
        })
      }

      drawPrecipitationLine({propertyName: 'snow', className: 'snow'})
      drawPrecipitationLine({propertyName: 'rain', className: 'rain'})

      weatherForecastContainer.appendChild(svg)
    }

    xhr.onload = () => {
      const forecastPoints = getForecastPointsFromXML()

      twoDayForecastPoints = forecastPoints.slice(0, 48)
      
      drawSVG(twoDayForecastPoints)

      window.onresize = () => {
        drawSVG(twoDayForecastPoints)
      }
    }

    xhr.open('GET',`https://forecast.weather.gov/MapClick.php?lat=${latitude}&lon=${longitude}&FcstType=digitalDWML`, true)
    xhr.responseType = 'document'
    xhr.send()

  </script>
</head>
<body>
  <weather-forecast></weather-forecast>
</body>
</html>
